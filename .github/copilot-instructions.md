# GitHub Copilot Instructions for Enterprise Support App

This document provides context and guidelines for GitHub Copilot when working on the Enterprise Support App project.

## Project Overview

The Enterprise Support App is a mobile-first support document hub built with React and Capacitor. It allows employees to quickly access curated IT support documents and contact information, designed to work offline. The app is built as a React web application that is packaged as a native iOS app using Capacitor, maintaining a single codebase.

**Key Architecture:**
- React 19 web application with TypeScript
- Capacitor for iOS native wrapper
- Vite for build tooling and development server
- Tailwind CSS for styling with theme support
- Markdown-based document system
- Enterprise-agnostic configuration via `app.config.json`

## Setup Instructions

### Prerequisites
- Node.js >= 22.0.0
- npm >= 10.0.0
- For iOS development (Mac only): Xcode, Xcode Command Line Tools, CocoaPods

### Initial Setup
```bash
# Clone and install dependencies
git clone https://github.com/archubbuck/enterprise-support.git
cd enterprise-support
npm install

# Start development server
npm run dev
# App runs at http://localhost:5000
```

### Configuration
Before development, configure the app by editing `app.config.json` or using a template:
```bash
# Use example templates
cp examples/app.config.startup.json app.config.json
# Then validate
npm run validate:app-config
```

### iOS Development (Mac Only)
```bash
# Build and sync to iOS
npm run ios:build

# Open in Xcode
npm run ios:open
```

## Technology Stack

- **React 19** - UI framework with functional components and hooks
- **TypeScript 5.9** - Type safety and better developer experience
- **Vite 7.3** - Fast build tool and dev server
- **Tailwind CSS 4.1** - Utility-first styling
- **Capacitor 8** - Native iOS wrapper
- **Framer Motion** - Animations
- **Radix UI** - Accessible component primitives
- **marked** - Markdown parsing for documents

## Project Structure

```
enterprise-support/
├── src/                   # React source code
│   ├── components/        # React components
│   ├── lib/              # Utilities and data
│   └── App.tsx           # Main application
├── docs/                 # Documentation files
├── public/               # Static assets
│   └── documents/        # Support document markdown files
├── ios/                  # iOS native project (generated by Capacitor)
├── dist/                 # Built web assets (generated)
├── app.config.json       # App-specific configuration
├── capacitor.config.ts   # Capacitor configuration
└── package.json          # Dependencies and scripts
```

## Coding Standards

### TypeScript/React
- **Always use TypeScript** for all new code
- Use **functional components** over class components
- Follow **React hooks** best practices
- Keep components **small and focused** (single responsibility)
- Use meaningful variable and function names
- Prefer type inference but add explicit types for public APIs
- Use `interface` for object types, `type` for unions/intersections

### Code Style
- Use **2 spaces** for indentation
- Use **single quotes** for strings (unless template literals are needed)
- Add **semicolons** at the end of statements
- Use **trailing commas** in objects and arrays
- Follow existing code patterns in the repository
- ESLint is configured - run `npm run lint` to check

### Naming Conventions
- **Components**: PascalCase (e.g., `DocumentList.tsx`)
- **Files**: kebab-case for utilities (e.g., `document-utils.ts`)
- **Functions**: camelCase (e.g., `loadDocuments`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_DOCUMENTS`)
- **Interfaces/Types**: PascalCase with descriptive names (e.g., `DocumentMetadata`)

## Configuration System

### app.config.json
This is the central configuration file for enterprise customization. It supports:
- JSON Schema validation (`schemas/app.config.schema.json`)
- TypeScript type safety via generated types
- Placeholders in documents (e.g., `{companyName}`, `{vpnPortal}`)
- Example templates in `examples/` directory

**Always validate configuration changes:**
```bash
npm run validate:app-config
```

### Theme System
The app supports multiple color themes defined in `src/lib/theme-config.ts`:
- Themes use Tailwind CSS variables
- Users can switch themes at runtime
- Theme configuration is documented in `docs/THEME_CONFIGURATION.md`

## Document Management

### Adding Support Documents
1. Create Markdown file in `public/documents/`
2. Use placeholders for company-specific information:
   - `{companyName}` - Company name from config
   - `{companyName.toUpperCase()}` - Uppercase company name
   - `{emergencyEmail}` - Emergency contact email
   - `{vpnPortal}` - VPN portal URL
3. Add entry to `public/documents/manifest.json`
4. Test document loads correctly

### Document Structure
```json
{
  "id": "unique-id",
  "title": "Document Title",
  "category": "category-name",
  "icon": "icon-name",
  "file": "filename.md",
  "tags": ["tag1", "tag2"]
}
```

For non-markdown documents (PDF, Word, images), add a `type` field:
```json
{
  "id": "security-policy",
  "title": "IT Security Policy (PDF)",
  "category": "Security",
  "icon": "file",
  "file": "sample-policy.pdf",
  "type": "pdf",
  "tags": ["security", "policy"]
}
```

## Development Workflow

### Building and Testing
```bash
# Run all checks (JSON validation, linting, config validation)
npm run check

# Individual checks
npm run lint
npm run validate:json
npm run validate:app-config
npm run validate:app-icon
npm run validate:metadata

# Build for production
npm run build

# iOS build and sync
npm run ios:build
```

### Making Changes
1. Create a feature branch: `git checkout -b feature/your-feature-name`
2. Make focused changes (one feature/fix per PR)
3. Test thoroughly (web and iOS if applicable)
4. Run `npm run check` before committing
5. Update documentation for user-facing changes
6. Create pull request with clear description

## Common Patterns

### Loading Configuration

Configuration can be accessed in two ways depending on the context:

#### At Build Time (vite.config.ts, capacitor.config.ts)
For build-time configuration files, import directly:
```typescript
import appConfig from './app.config.json';

// Access configuration values
const companyName = appConfig.companyName;
const appId = appConfig.appId;
```

#### At Runtime (React Components)
For React components, use the `useAppConfig` hook:
```typescript
import { useAppConfig } from '@/hooks/useAppConfig';

function MyComponent() {
  const { config, loading, error } = useAppConfig();
  
  if (loading) return <Spinner />;
  if (error) return <ErrorMessage error={error} />;
  if (!config) return null;
  
  return <div>{config.companyName}</div>;
}
```

The `useAppConfig` hook provides:
- Automatic caching with localStorage (24-hour TTL)
- Stale-while-revalidate pattern for offline resilience
- Loading and error states
- Type safety through AppConfig interface

### Markdown Document Loading
Documents are loaded from `public/documents/` and parsed with `marked`:
```typescript
import { marked } from 'marked';

// Load and parse markdown
const response = await fetch('/documents/example.md');
const markdown = await response.text();
const html = marked.parse(markdown);
```

### Component Structure
Prefer this structure for components:
```typescript
import { useState } from 'react';
import { SomeType } from './types';

interface ComponentProps {
  prop1: string;
  prop2?: number;
}

export function Component({ prop1, prop2 = 0 }: ComponentProps) {
  const [state, setState] = useState<SomeType | null>(null);

  // Event handlers
  const handleClick = () => {
    // ...
  };

  // Effects
  // ...

  return (
    <div>
      {/* JSX */}
    </div>
  );
}
```

### Error Handling
The app uses React Error Boundaries:
- Wrap components that might throw errors
- Provide user-friendly error messages
- Log errors appropriately

## Capacitor Integration

### iOS-Specific Features
- App runs in WKWebView
- Native iOS navigation and UI elements
- Offline support via service workers and local storage
- Access to native iOS APIs when needed

### Syncing Changes to iOS
After making changes:
1. Build web app: `npm run build`
2. Sync to iOS: `npx cap sync ios`
3. Or use combined command: `npm run ios:build`

## Important Constraints

### Enterprise-Agnostic Design
- Never hardcode company-specific information in code
- Always use `app.config.json` for organization-specific data
- Use placeholders in documents that are replaced at runtime
- Make features configurable rather than hardcoded

### Offline-First
- All documents must be available offline
- No external API dependencies for core functionality
- Local storage for user preferences and settings
- Service workers for caching (if implemented)

### iOS App Store Compliance
- Follow Apple's Human Interface Guidelines
- Ensure privacy policy compliance
- Test on actual iOS devices before release
- Maintain app icon and metadata requirements

## Testing

Currently, the project does not have automated tests. When adding features:
- Test manually in development environment (`npm run dev`)
- Test in iOS simulator (Mac developers)
- Test on actual iOS devices when possible
- Verify offline functionality
- Test different configurations

## Documentation

### When to Update Documentation
Update relevant documentation when:
- Adding new features
- Changing configuration options
- Modifying development workflows
- Updating dependencies
- Changing build/deployment processes

### Documentation Files
- `README.md` - Project overview and quick start
- `docs/QUICK_START.md` - Getting started guide
- `docs/CONFIGURATION.md` - Configuration system details
- `docs/THEME_CONFIGURATION.md` - Theme system documentation
- `docs/iOS_DEVELOPMENT.md` - iOS-specific development
- `docs/DEPLOY_SETUP.md` - Deployment configuration
- `docs/DOCUMENTS.md` - Document management
- `.github/CONTRIBUTING.md` - Contributing guidelines

## Common Tasks

### Adding a New Feature
1. Check if it requires configuration - add to `app.config.json` schema if needed
2. Implement in `src/` with TypeScript
3. Follow existing component patterns
4. Test in web browser first
5. Test in iOS simulator/device
6. Update relevant documentation
7. Run `npm run check` before committing

### Adding a New Document
1. Create `.md` file in `public/documents/`
2. Use placeholders: `{companyName}`, `{vpnPortal}`, etc.
3. Add entry to `public/documents/manifest.json`
4. Test document rendering
5. Verify placeholders are replaced correctly

### Modifying Configuration Schema
1. Edit `schemas/app.config.schema.json`
2. Update TypeScript types if needed
3. Update example configurations in `examples/`
4. Test validation: `npm run validate:app-config`
5. Update `docs/CONFIGURATION.md`

### Adding a New Theme
1. Add theme definition to `src/lib/theme-config.ts`
2. Define color variables using Tailwind format
3. Test theme switching in UI
4. Update `docs/THEME_CONFIGURATION.md`

## Troubleshooting

### Common Issues
- **Build errors**: Run `npm install` to ensure dependencies are up to date
- **iOS build fails**: Ensure Xcode Command Line Tools are installed
- **Config validation fails**: Check `schemas/app.config.schema.json` for requirements
- **Port 5000 in use**: Run `npm run kill` to free the port

### Debugging
- Use browser DevTools for web development
- Use Safari Web Inspector for iOS debugging
- Check console logs for errors
- Verify file paths are correct (case-sensitive on some systems)

## Additional Resources

- [Quick Start Guide](../docs/QUICK_START.md)
- [Configuration Guide](../docs/CONFIGURATION.md)
- [iOS Development Guide](../docs/iOS_DEVELOPMENT.md)
- [Contributing Guide](./CONTRIBUTING.md)
- [Troubleshooting Guide](../docs/TROUBLESHOOTING.md)

## Key Principles for Copilot

When generating code for this project:

1. **Type Safety First** - Always use TypeScript with proper types
2. **Configuration Over Code** - Use `app.config.json` for customization
3. **Consistency** - Follow existing patterns and conventions
4. **Documentation** - Include JSDoc comments for complex logic
5. **Mobile-First** - Consider iOS experience in design decisions
6. **Offline-First** - Ensure features work without network
7. **Accessibility** - Use Radix UI components for accessible patterns
8. **Performance** - Keep components small and optimize renders
9. **Maintainability** - Write clear, self-documenting code
10. **Testing** - Consider manual testing steps for changes
